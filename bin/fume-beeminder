#!/usr/bin/env ruby

# Simple script to get old fume data and send it to beeminder. Put it in a daily
# cron job. Pay for dreeves' hookers.

require "beeminder"
require "chronic"
require 'net/https'
require "optparse"
require "set"
require "uri"

begin
  require 'fume'
rescue LoadError
  if File.symlink? __FILE__
    require File.dirname(File.readlink(__FILE__)) + '/../lib/fume'
  else
    require File.dirname(__FILE__) + '/../lib/fume'
  end
end

margin = Chronic.parse("1 hour ago")

# load configs
options = {}
OptionParser.new do |opts|
  opts.banner = "usage: fume-beeminder [-f]"

  opts.on("-f", "--force", "force update") do |o|
    options[:force] = o
  end
  opts.on("-d", "--debug", "debug") do |o|
    options[:debug] = o
  end
  opts.on("-n", "--pretend", "pretend to send data") do |o|
    options[:pretend] = o
  end
end.parse!
bee_log = File.join(Fume::Config["fume_dir"], Fume::Config["beeminder"])
yaml    = YAML::load(File.open(bee_log))

# find unreported entries
Fumetrap::CLI.args = Getopt::Declare.new("#{Fumetrap::CLI::USAGE}")
Fumetrap::CLI.parse "all -s #{yaml["start"]}"

puts "getting unreported entries..." if options[:debug]
entries = Fumetrap::CLI.unreported_entries
puts "found: #{entries.count}" if options[:debug]

if entries.count.zero?
  puts "nothing to do..." if options[:debug]
  exit
end

# load fume data
puts "loading fume data..." if options[:debug]
fmt  = "%Y-%m-%d"
fume = Fume::CLI.new
fume.load_file
fume.fumes.update_quotas(fume.fumes.filter_since yaml["start"].strftime(fmt))
contexts = Set.new(fume.fumes.contexts.map(&:name))

# select entries in a valid context and not too new
to_report = entries.to_a.reject {|entry| not contexts.include?(entry.sheet) or (entry.end >= margin and not options[:force])}

if to_report.empty?
  puts "nothing to update (yet)..." if options[:debug]
  exit
end

# build data for all goals
data = {}
yaml["goals"].each do |goal|
  # only use entries from certain contexts, if specified, or all otherwise
  allowed_contexts = goal["contexts"].nil? ? contexts : Set.new([*goal["contexts"]].flatten)
  puts "to report for #{goal["name"]}:" if options[:debug]

  valid = to_report.select {|e| allowed_contexts.include? e.sheet}
  next if valid.empty?

  # we assume only cumulative goals
  score = "%0.2f" % valid.reduce(0) do |score, entry|
    puts "  -> #{entry.sheet}" if options[:debug]
    
    # build data point
    score + case goal["type"]
            when "time"
              entry.duration / (60.0*60.0)
            when "boxes"
              1
            else
              raise "unknown goal type"
            end
  end
  date = valid.max_by{|e| e.start}.start
  used_contexts = valid.map{|e| e.sheet}.uniq
  comment = "#{goal["name"]} update, context#{valid.size > 1 ? "s" : ""}: #{used_contexts.sort.join(", ")}"

  body = {
    date: date,
    comment: comment,
    value: score,
  }
  
  data[goal["name"]] = body
end

# send data
data.each do |goal, body|
  if options[:pretend]
    puts "would send:"
    puts body
  else
    config = YAML.load File.open("#{Dir.home}/.beeminderrc")
    bee = Beeminder::User.new config["account"], config["token"]
    g = bee.goal goal
    dp = Beeminder::Datapoint.new("timestamp" => body[:date].strftime('%s'),
                                  "value" => body[:value],
                                  "comment" => body[:comment])
    g.add dp
  end
end

# save data
puts "saving..." if options[:debug]
to_report.each do |entry|
  entry.reported!
  entry.save unless options[:pretend]
end
