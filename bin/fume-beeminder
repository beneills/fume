#!/usr/bin/env ruby

# Simple script to get old fume data and send it to beeminder. Put it in a daily
# cron job. Pay for dreeves' hookers.

debug = false
send  = true

require "chronic"
require "set"
require "optparse"

options = {}
OptionParser.new do |opts|
  opts.banner = "usage: fume-beeminder [-f]"

  opts.on("-f", "--force", "force update") do |v|
    options[:force] = v
  end
end.parse!
  
begin
  require 'fume'
rescue LoadError
  if File.symlink? __FILE__
    require File.dirname(File.readlink(__FILE__)) + '/../lib/fume'
  else
    require File.dirname(__FILE__) + '/../lib/fume'
  end
end

# get all days we haven't reported yet
bee_log = File.join(Fume::Config["fume_dir"], Fume::Config["beeminder"])
yaml = YAML::load(File.open(bee_log))
Fumetrap::CLI.args = Getopt::Declare.new("#{Fumetrap::CLI::USAGE}")
Fumetrap::CLI.parse "all -s #{yaml["start"]}"

puts "getting unreported entries..." if debug
unreps = Fumetrap::CLI.unreported_entries
puts "found: #{unreps.count}" if debug

if unreps.count.zero?
  puts "nothing to do..." if debug
  exit
end

# load fume data
puts "loading fume data..." if debug
fmt  = "%Y-%m-%d"
fume = Fume::CLI.new
fume.load_file
fume.fumes.update_quotas(fume.fumes.filter_since yaml["start"].strftime(fmt))
contexts = Set.new(fume.fumes.contexts.map(&:name))

# report each entry
valid = []
time_body = ""
margin = Chronic.parse("1 hour ago")
unreps.each do |entry|
  # check if it's in a valid context and not too new
  next if not contexts.include? entry.sheet
  next if entry.end >= margin and not options[:force]

  # build data point
  date = entry.start
  score = "%0.2f" % (entry.duration / (60.0*60.0))
  text  = "fume update, context: #{entry.sheet}"
  time_body << "#{date.strftime("%Y %m %d")} #{score} \"#{text}\"\n"

  # mark it as done later
  valid << entry
end

if valid.empty?
  puts "nothing to update (yet)..." if debug
  exit
end

# report all valid boxes in second goal
date = valid.max_by{|e| e.start}.start
score = valid.size
text  = "timebox update, contexts: #{valid.map{|e| e.sheet}.uniq.sort.join(",")}"
boxes_body = "#{date.strftime("%Y %m %d")} #{score} \"#{text}\"\n"

# send data
if not send
  puts "would send:"
  puts "time:"
  puts time_body
  puts "boxes:"
  puts boxes_body
else
  def send_beeminder account, goal, data
    require 'net/http'
    
    base = "http://beta.beeminder.com"
    cmd  = "create_all"
    api  = "#{base}/#{account}/goals/#{goal}/datapoints/#{cmd}"

    begin # connect
      url = URI.parse(api)
      http = Net::HTTP.new(url.host, url.port)
      http.read_timeout = 8640
      http.start do |http|
        req = Net::HTTP::Post.new(url.path)
        req.set_form_data({"datapoints_text" => data,
                            "origin" => "#{account}_api",
                            "sendmail" => false})
        res = http.request(req)
      end
    rescue StandardError, Timeout::Error
      put "connection failed..."
      put res
      exit 1
    end
  end

  send_beeminder yaml["account"], yaml["goal-time"],  time_body
  send_beeminder yaml["account"], yaml["goal-boxes"], boxes_body
end

# save data
puts "saving..." if debug
valid.each do |entry|
  entry.reported!
  entry.save if send
end
